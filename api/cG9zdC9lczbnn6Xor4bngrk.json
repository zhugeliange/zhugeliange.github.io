{"title":"es6知识点","date":"2020-03-13T06:10:44.000Z","slug":"es6知识点","comments":true,"tags":["es6","javascript","前端","知识点"],"categories":["javascript"],"updated":"2020-04-21T02:24:15.000Z","content":"<html><head></head><body><ul><li><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = {};</span><br><span class=\"line\">a.prop = <span class=\"number\">1</span>; <span class=\"comment\">// 为a添加一个属性，可以成功</span></span><br><span class=\"line\">foo = {}; <span class=\"comment\">// 将a指向另一个对象，就会报错</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如果解构赋值的默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = b()] = [<span class=\"number\">1</span>]; <span class=\"comment\">// 因为a能取到值1，所以函数b根本不会执行。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>解构赋值的默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">1</span>, b = a] = [];     <span class=\"comment\">// a=1; b=1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = <span class=\"number\">1</span>, b = a] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">// a=1; b=2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a = b, b = <span class=\"number\">1</span>] = [];     <span class=\"comment\">// 报错，因为b还没有声明就被赋值给了a</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>数组和对象都可以解构赋值，不过对象的解构赋值不是按照顺序一一对应，而是按照key来对应的。</p></li><li><p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。如果参数类型不是数值，律返回false。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">15</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'foo'</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">true</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，一律返回false。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">9</span>/<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span> / <span class=\"number\">0</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span> / <span class=\"string\">'true'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">15</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'15'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">true</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>函数的递归可能会造成内存溢出，影响性能，可以用尾调用来优化，即最后一步调用。</p></li><li><p>Array.from方法用于将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map），转为真正的数组。</p></li><li><p>Array.of()方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,] 参数只有一个正整数时，实际上是指定数组的长度</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array.of()基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p></li><li><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。支持NaN的判断。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value > <span class=\"number\">9</span>;</span><br><span class=\"line\">}) <span class=\"comment\">// 10</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p></li><li><p>findIndex方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。支持NaN的判断。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value > <span class=\"number\">9</span>;</span><br><span class=\"line\">}) <span class=\"comment\">// 2</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p></li><li><p>includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p></li><li>一共两个参数，第一个参数表示目标值，第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度，则会重置为从0开始。</li><li>支持NaN的判断，可以用来替换indexOf。</li><li><p>类似的有Map结构的has方法，是用来查找键名的。Set结构的has方法，是用来查找值的。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>flat()方法会将数组‘拉平’为一维数组，且 不改变原数组。默认只‘拉平’一层，要想多层可以传参数指定，参数为Infinity表示不管原数组多少层，全部变为一维数组。</p></li><li><p>允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，除了属性简写，方法也可以简写。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> c = {<span class=\"attr\">a</span>: b};</span><br><span class=\"line\"> <span class=\"comment\">// 等同于 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">'b'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = {a};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> {x, y};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> {<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// Object {x: 1, y: 2}</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = {</span><br><span class=\"line\">  method() {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = {</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>fromEntries()方法是entries()方法的逆操作，用于将一个键值对数组转为对象。常用来配合URLSearchParams对象，将查询字符串转为对象。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.fromEntries(<span class=\"keyword\">new</span> URLSearchParams(<span class=\"string\">'foo=bar&baz=qux'</span>)); <span class=\"comment\">// { foo: \"bar\", baz: \"qux\" }</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。对于数组也会当作对象来处理，所以属性肯定会重复。如果属性名相同则后面的替换前面的。</p></li><li><p>set结构，元素不能重复，内部严格比较，例如1和‘1’不相等，用new Set()来生成。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 去除数组中的重复元素</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>])] <span class=\"comment\">// [1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去除字符串的重复字符</span></span><br><span class=\"line\">[...new <span class=\"built_in\">Set</span>(<span class=\"string\">'ababbc'</span>)].join(<span class=\"string\">''</span>) <span class=\"comment\">// ‘abc’</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>set结构有size属性表示元素个数，add方法添加元素（重复的元素会自动忽略），delete方法删除元素，has方法查找元素是否存在，clear方法清除所有元素。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>]);</span><br><span class=\"line\">a.add(<span class=\"number\">3</span>); <span class=\"comment\">// [1,2,3]</span></span><br><span class=\"line\">a.delete(<span class=\"number\">2</span>); <span class=\"comment\">// [1,3]</span></span><br><span class=\"line\">a.has(<span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">a.clear();</span><br></pre></td></tr></tbody></table></figure></li><li><p>set结构的遍历方法：keys方法遍历所有的键名，values方法遍历所有的值，entries方法遍历所有的键值对，forEach使用回调函数遍历每个成员。</p></li><li><p>set结构的键名就是键值，所以keys方法和values方法等价。</p></li><li><p>map结构使用new Map()来生成，传统的object对象结构的键名只能是字符串，而map结构的键名可以是任意类型，所以键值对的hash类型更推荐用map。</p></li><li><p>结构有size属性表示元素个数，set方法添加元素（键名重复则会替换），get方法根据键名获取值（键名找不到则返回undefined），has方法查找值（参数为值不是键名）是否存在，delete方法根据键名删除元素，clear方法清除所有元素。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'c'</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"string\">'d'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\">a.set(<span class=\"number\">2</span>,<span class=\"string\">'e'</span>); <span class=\"comment\">// Map { 'a' => 'b', 'c' => 2, 1 => 'd', 2 => 'e' }</span></span><br><span class=\"line\">a.get(<span class=\"number\">2</span>); <span class=\"comment\">// 'e'</span></span><br><span class=\"line\">a.has(<span class=\"number\">2</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">a.delete(<span class=\"number\">2</span>); <span class=\"comment\">// Map { 'a' => 'b', 'c' => 2, 1 => 'd' }</span></span><br><span class=\"line\">a.clear(); <span class=\"comment\">// Map {}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>map结构的遍历方法：keys方法遍历所有的键名，values方法遍历所有的值，entries方法遍历所有的键值对，forEach使用回调函数遍历每个成员。</p></li><li><p>map结构与其他结构的互相转换：</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'c'</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"string\">'d'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map转换为数组，使用扩展运算符或者Array.from()方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = [...a]; <span class=\"comment\">// [ [ 'a', 'b' ], [ 'c', 2 ], [ 1, 'd' ] ]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"built_in\">Array</span>.from(a); <span class=\"comment\">// [ [ 'a', 'b' ], [ 'c', 2 ], [ 1, 'd' ] ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组转换为map，直接当成参数传入new Map()方法即可</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(c); <span class=\"comment\">// Map { 'a' => 'b', 'c' => 2, 1 => 'd' }</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map转换为对象，如果map的所有键都是字符串，则可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> e = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">d.forEach(<span class=\"function\">(<span class=\"params\">v,k</span>)=></span>{</span><br><span class=\"line\">  e[k] = v;</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象转换为map，通过Object.entries()方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">Object</span>.entries(e)); <span class=\"comment\">// Map { '1' => 'd', 'a' => 'b', 'c' => 2 }</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map转换为json，分为两种：如果map的键名全部都是字符串则可以转换为json对象（即先用JSON.stringify()方法转换成对象再转换成json），否则转换为json数组（即先用JSON.stringify()方法转换成数组再转换成json）。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> g = <span class=\"built_in\">JSON</span>.stringify(e); <span class=\"comment\">// {\"1\":\"d\",\"a\":\"b\",\"c\":2}</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"built_in\">JSON</span>.stringify(b); <span class=\"comment\">// [[\"a\",\"b\"],[\"c\",2],[1,\"d\"]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// json转换为map，分为两种：如果是键名全部都是字符串的json对象可以先用JSON.parse()方法转换成对象再用Object.entries()方法遍历，最后用new Map()方法生成map；否则键名不为字符串，或者多层数组或对象嵌套的json数组可以先用JSON.parse()方法转换成数组，再用new map()方法生成。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">Object</span>.entries(<span class=\"built_in\">JSON</span>.parse(g))); <span class=\"comment\">// Map { '1' => 'd', 'a' => 'b', 'c' => 2 }</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> j = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">JSON</span>.parse(h)); <span class=\"comment\">// Map { 'a' => 'b', 'c' => 2, 1 => 'd' }</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Promise是异步编程的一种解决方案，用new Promise()方法来生成。</p></li><li>Promise对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>Promise对象一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li><li>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li><li>Promise对象有then(方法表示状态改变时的回调函数。有两个可选参数参数，第一个参数为状态成功时的回调函数，第二个参数为状态失败时的回调函数。</li><li><p>Promise对象也有catch()方法和finally()方法来表示捕获异常和最终执行。</p></li><li><p>Generator函数是分段执行的，每次手动调用next()方法执行时，碰到函数内部的yield定义的状态就会停止，等到下次执行时再从上次停止的地方接着执行，是一种异步函数。</p></li><li>Generator函数与两个特征：一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。</li><li><p>async和await是Generator函数的最佳实践，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p></li><li><p>在Class的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，并拦截该属性的存取行为。</p></li><li><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p></li><li><p>只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，优先使用map结构。</p></li></ul></body></html>","prev":{"title":"typescript知识点","slug":"typeScript知识点"},"next":{"title":"tcp四层网络模型","slug":"tcp四层网络模型"},"link":"/post/es6知识点/","reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/es6知识点/\" title=\"es6知识点\">/post/es6知识点/</a>"}}
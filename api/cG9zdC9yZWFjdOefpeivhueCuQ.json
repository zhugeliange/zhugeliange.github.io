{"title":"react知识点","date":"2021-02-10T01:10:40.000Z","slug":"react知识点","comments":true,"tags":["react","前端","知识点"],"categories":["react"],"updated":"2021-03-13T05:18:12.000Z","content":"<html><head></head><body><ul><li><p>jsx里自定义的组件必须以大写字母开头，原生组件以小写字母开头，且可以使用属性语法，例如：<menu.item></menu.item></p></li><li><p>只存最原始的状态，凡是需要计算得到的值都不建议单独存储，而是通过计算得到。</p></li><li><p>组件尽量无状态，所有的数据通过props获取。</p></li><li><p>react router分为三种形式：普通url模式，hash模式（多个#，用于兼容旧版本浏览器），内存模式（类似于存储在state中，url中不显示）。</p></li><li><p>react router常用api：</p><ul><li><link>：普通链接，但是不会触发浏览器的刷新。</li><li><navlink>：类似于Link，但是多了个选中状态。</navlink></li><li><prompt>：满足条件时提示用户是否离开当前页面。</prompt></li><li><redirect>：页面重定向跳转，例如登录判断。</redirect></li><li><route>：最基本的路由，根据路径匹配显示相应的页面或组件。</route></li><li><switch>：多个Route的匹配规则都满足时，默认会都显示，如果只想显示第一个，可以用Switch将多个Route包起来。</switch></li></ul></li><li><p>next.js适合重度依赖ssr的首页性能优先项目，其他情况下create react app都可以满足日常需求。</p></li><li><p>webpack是先编译打包，然后再启动服务器，而vite是先启动服务器，然后按需加载编译资源。</p></li><li><p>开发构建vite优先，因为性能更好，生产构建webpack优先，因为功能更加齐全。</p></li><li><p>redux原理：用户更改view触发一个action，dispatch接收这个action交给相应的reducer，reducer更新相应的store，从而触发ui的更新。</p></li><li><p>因为render最外层只能有一个标签，所以如果有多个标签时，可以用<fragment>标签包起来。</fragment></p></li><li><p><fragment>标签只有key可选属性，适合遍历时指定。也可以用<>的形式，但是没有key属性。</fragment></p></li><li><p>React.lazy函数用来动态import组件，即用到的时候才加载，配合Suspense可以实现，等待加载未完成时显示相应的loading效果。</p></li><li><p>错误边界组件，可以捕获并打印发生在其子组件树任何位置的JavaScript错误，并且会渲染出备用UI。适合用来处理React组件内部崩溃引发的界面白屏等错误（正常的请求报错或者页面事件抛出异常等错误不算）。</p></li><li><p>当多个不同层级的组件之间需要共享状态时，依次逐层通过props来传递state会使得代码太过冗余。可以使用context，比如说当前认证的用户、主题或首选语言等。</p></li><li><p>不过context会造成一定性能的损耗，替代方案可以将整个子组件直接传入props来传递state。</p></li><li><p>当处理一些原生组件或者第三方组件时，需要直接操作dom，可以使用ref来直接访问原生dom。</p></li><li><p>组件是将props转换为ui，而高阶组件是将组件转换为另一个组件，即高阶组件的props参数是组件。</p></li><li><p>Portals可以将子节点渲染到父节点之外，并且保持和普通子结点相对于父节点一致的行为。适合model弹框之类的场景。</p></li><li><p><a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">React组件生命周期：</a></p><ul><li>挂载时：constructor -> render -> React更新dom和refs -> componentDidMount</li><li>更新时：constructor -> render(New props()/setState()/forceUpdate()) -> React更新dom和refs -> componentDidUpdate</li><li>卸载时：componentWillUnmount</li></ul></li></ul></body></html>","next":{"title":"typescript知识点","slug":"typeScript知识点"},"link":"/post/react知识点/","reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/react知识点/\" title=\"react知识点\">/post/react知识点/</a>"}}
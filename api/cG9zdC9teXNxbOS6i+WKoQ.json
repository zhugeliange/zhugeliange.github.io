{"title":"mysql事务","date":"2017-11-03T07:27:57.000Z","slug":"mysql事务","comments":true,"tags":["mysql","事务"],"categories":["mysql"],"updated":"2019-04-03T07:27:57.000Z","content":"<html><head></head><body><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul><li><p><strong>MySQL</strong> 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中删除一个人员，既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这些数据库操作语句就构成一个事务。</p></li><li><p>在 <strong>MySQL</strong> 中只有使用了 <strong>InnoDB</strong> 数据库引擎的数据库或表才支持事务。</p></li><li><p>事务处理可以用来维护数据库的完整性，保证成批的 <strong>SQL</strong> 语句要么全部执行，要么全部不执行。</p></li><li><p>事务用来管理 <strong>INSERT</strong>，<strong>UPDATE</strong>，<strong>DELETE</strong> 语句。</p></li><li><p><strong>MySQL</strong> 默认事务都是自动提交的，即执行 <strong>SQL</strong> 语句后就会马上执行 <strong>COMMIT</strong> 操作。因此要显式地开启一个事务必须使用命令 <strong>BEGIN</strong> 或 <strong>START TRANSACTION</strong>，或者执行命令 <strong>SET AUTOCOMMIT=0</strong>，用来禁止使用当前会话的自动提交，<strong>SET AUTOCOMMIT=1</strong> 可以再次设置为自动提交。</p></li></ul><h2 id=\"事务具有的四个特性\"><a href=\"#事务具有的四个特性\" class=\"headerlink\" title=\"事务具有的四个特性\"></a>事务具有的四个特性</h2><ul><li><p><strong>原子性：</strong> 一个事务（<strong>TRANSACTION</strong>）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（<strong>ROLLBACK</strong>）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>一致性：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，InnoDB 存储引擎提供的包括：</p><ul><li><p>读未提交（<strong>READ UNCOMMITTED</strong> ）：事务 <strong>A</strong> 未提交的数据，事务 <strong>B</strong> 可以读取到， 这里读取到的数据叫做 <strong>脏数据</strong>。这种隔离级别最低，这种级别一般只在理论上存在实际中很少使用，数据库隔离级别一般都高于该级别。</p></li><li><p>读已提交（<strong>READ COMMITTED</strong>）：只有事务 <strong>A</strong>已经提交的数据，事务 <strong>B</strong> 才能读取到，这种隔离级别高于读未提交，这种级别可以避免 <strong>脏数据</strong>，但是会导致 <strong>不可重复读取</strong>。</p></li><li><p>可重复读（<strong>REPEATABLE READ</strong>）：即使事务 <strong>A</strong> 提交之后的数据，事务 <strong>B</strong> 也读取不到，事务 <strong>B</strong> 是可重复读取数据，这种隔离级别高于读已提交可以避免 <strong>不可重复读取</strong>，但是会导致 <strong>幻读</strong>。是 <strong>MySQL</strong> 的默认隔离级别。</p></li><li><p>串行化（<strong>SERIALIZABLE</strong>）：事务 <strong>A</strong> 在操作数据库时，事务 <strong>B</strong> 只能排队等待，这种隔离级别很少使用，吞吐量太低用户体验差，这种级别可以避免 <strong>幻读</strong>，每一次读取的都是数据库中真实存在数据，事务 <strong>A</strong> 与事务 <strong>B</strong> 串行而不并发，即一个一个来不能同时运行。</p></li></ul></li><li><p><strong>持久性：</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2 id=\"事务控制语句\"><a href=\"#事务控制语句\" class=\"headerlink\" title=\"事务控制语句\"></a>事务控制语句</h2><ul><li><p><strong>BEGIN</strong> 或 <strong>START TRANSACTION</strong> 显式地开启一个事务。</p></li><li><p><strong>COMMIT</strong> 也可以使用 <strong>COMMIT WORK</strong>，不过二者是等价的。<strong>COMMIT</strong> 会提交事务，并使已对数据库进行的所有修改成为永久性的。</p></li><li><p><strong>ROLLBACK</strong> 也可以使用 <strong>ROLLBACK WORK</strong>，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</p></li><li><p><strong>SAVEPOINT identifier</strong>，<strong>SAVEPOINT</strong> 允许在事务中创建一个保存点，一个事务中可以有多个 <strong>SAVEPOINT</strong>。</p></li><li><p><strong>RELEASE SAVEPOINT identifier</strong> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。</p></li><li><p><strong>ROLLBACK TO identifier</strong> 把事务回滚到保存点。</p></li><li><p><strong>SET TRANSACTION</strong> 用来设置事务的隔离级别。</p></li></ul><h2 id=\"四种隔离级别产生的并发问题\"><a href=\"#四种隔离级别产生的并发问题\" class=\"headerlink\" title=\"四种隔离级别产生的并发问题\"></a>四种隔离级别产生的并发问题</h2><ul><li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p></li><li><p>当隔离级别为串行化（<strong>SERIALIZABLE</strong>）时可以保证数据的绝对完整但此时读写数据都会锁住整张表，因此效率会大大降低。</p></li><li><p><strong>脏读：</strong> 事务 <strong>A</strong> 读取了事务 <strong>B</strong> 更新的数据，然后 <strong>B</strong> 回滚操作，那么 <strong>A</strong> 读取到的数据是脏数据。</p></li><li><p><strong>不可重复读：</strong> 事务 <strong>A</strong> 多次读取同一数据，事务 <strong>B</strong> 在事务 <strong>A</strong> 多次读取的过程中，对数据作了更新并提交，导致事务 <strong>A</strong> 多次读取同一数据时，结果不一致。</p></li><li><p><strong>幻读：</strong> 事务 <strong>A</strong> 多次读取同一数据，事务 <strong>B</strong> 在事务 <strong>A</strong> 多次读取的过程中，插入或删除了一些数据并提交，导致事务 <strong>A</strong> 多次读取同一数据时，发现多了或少了一些数据。</p></li><li><p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p></li></ul><table><thead><tr><th style=\"text-align:left\">隔离级别</th><th style=\"text-align:center\">脏读</th><th style=\"text-align:center\">不可重复读</th><th style=\"text-align:center\">幻读</th></tr></thead><tbody><tr><td style=\"text-align:left\">读未提交（<strong>READ UNCOMMITTED</strong> ）</td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td></tr><tr><td style=\"text-align:left\">读已提交（<strong>READ COMMITTED</strong>）</td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td></tr><tr><td style=\"text-align:left\">可重复读（<strong>REPEATABLE READ</strong>）</td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td></tr><tr><td style=\"text-align:left\">串行化（<strong>SERIALIZABLE</strong>）</td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td></tr></tbody></table></body></html>","prev":{"title":"markdown查漏补缺","slug":"markdown查漏补缺"},"next":{"title":"mysql的正则表达式regexp","slug":"mysql的正则表达式regexp"},"link":"/post/mysql事务/","toc":[{"title":"","id":"四种隔离级别产生的并发问题","index":"1"}],"reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/mysql事务/\" title=\"mysql事务\">/post/mysql事务/</a>"}}
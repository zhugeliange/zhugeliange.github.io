{"title":"mysql查漏补缺","date":"2016-03-28T06:25:06.000Z","slug":"mysql查漏补缺","comments":true,"tags":["mysql","查漏补缺"],"categories":["mysql"],"updated":"2019-03-28T10:59:52.805Z","content":"<html><head></head><body><h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><ul><li><strong>mysql</strong> 建议 <strong>5.6</strong> 版本以上，最好是 <strong>5.7</strong> 版本，<strong>5.6</strong> 版本建议内存不小于 <strong>512M</strong>，<strong>5.7</strong> 版本建议内存不小于 <strong>1G</strong>。</li></ul><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><h3 id=\"Windows-和-Mac-直接下载安装包按照提示操作即可。\"><a href=\"#Windows-和-Mac-直接下载安装包按照提示操作即可。\" class=\"headerlink\" title=\"Windows 和 Mac 直接下载安装包按照提示操作即可。\"></a><strong>Windows</strong> 和 <strong>Mac</strong> 直接下载安装包按照提示操作即可。</h3><h3 id=\"Linux：\"><a href=\"#Linux：\" class=\"headerlink\" title=\"Linux：\"></a><strong>Linux：</strong></h3><ul><li><strong>Ubuntu</strong>，<strong>CentOS</strong> 这些常见发行版可以通过自带的包管理工具安装即可。</li></ul><figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get/yum install mysql-server</span><br></pre></td></tr></tbody></table></figure><ul><li>也可以通过 <strong>Docker</strong> 的方式进行安装。</li></ul><figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mysql/mysql-server</span><br><span class=\"line\">docker run mysql</span><br></pre></td></tr></tbody></table></figure><ul><li>或者也可以通过下载安装包安装（太麻烦不推荐，这里可以直接参考 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">官方文档</a>）。</li></ul><h2 id=\"mysql-的备份与还原\"><a href=\"#mysql-的备份与还原\" class=\"headerlink\" title=\"mysql 的备份与还原\"></a><strong>mysql</strong> 的备份与还原</h2><h3 id=\"导出指定数据库到文件\"><a href=\"#导出指定数据库到文件\" class=\"headerlink\" title=\"导出指定数据库到文件\"></a>导出指定数据库到文件</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqldump  -u 用户名 -p 数据库名>文件名.sql</span><br></pre></td></tr></tbody></table></figure><h3 id=\"由文件导入指定数据库\"><a href=\"#由文件导入指定数据库\" class=\"headerlink\" title=\"由文件导入指定数据库\"></a>由文件导入指定数据库</h3><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u 用户名 -p 数据库名<文件名.sql< span><br></文件名.sql<></span></pre></td></tr></tbody></table></figure><p>或者</p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u 用户名 -p # 输入密码登陆 mysql</span><br><span class=\"line\">use 数据库名 # 使用指定的数据库，不存在就先创建</span><br><span class=\"line\">source 文件名.sql # 导入</span><br></pre></td></tr></tbody></table></figure><h2 id=\"三范式\"><a href=\"#三范式\" class=\"headerlink\" title=\"三范式\"></a>三范式</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul><li><p><strong>第一范式：</strong> 当关系模式 <strong>R</strong> 的所有属性都不能在分解为更基本的数据单位时，称 <strong>R</strong> 是满足第一范式的，简记为 <strong>1NF</strong> 。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。简而言之：<strong>字段不可分</strong> 。</p></li><li><p><strong>第二范式：</strong> 如果关系模式 <strong>R</strong> 满足第一范式，并且 <strong>R</strong> 的所有非主属性都完全依赖于 <strong>R</strong> 的每一个候选关键属性，称 <strong>R</strong> 满足第二范式，简记为 <strong>2NF</strong>。简而言之：<strong>有主键，非主键字段完全依赖主键</strong> 。</p></li><li><p><strong>第三范式：</strong> 假设 <strong>R</strong> 是一个满足第一范式条件的关系模式，<strong>X</strong> 是 <strong>R</strong> 的任意属性集，如果 <strong>X</strong> 非传递依赖于 <strong>R</strong> 的任意一个候选关键字，称 <strong>R</strong> 满足第三范式，简记为 <strong>3NF</strong>。简而言之：<strong>非主键字段之间不能相互依赖</strong> 。</p></li></ul><h3 id=\"第一范式\"><a href=\"#第一范式\" class=\"headerlink\" title=\"第一范式\"></a>第一范式</h3><ul><li><p>每一列属性都是不可再分的属性值，确保每一列的原子性。</p></li><li><p>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</p></li></ul><h3 id=\"第二范式\"><a href=\"#第二范式\" class=\"headerlink\" title=\"第二范式\"></a>第二范式</h3><ul><li>每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</li></ul><h3 id=\"第三范式\"><a href=\"#第三范式\" class=\"headerlink\" title=\"第三范式\"></a>第三范式</h3><ul><li>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。</li></ul><h3 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h3><ul><li>三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求 > 性能 > 表结构。所以不能一味的去追求范式建立数据库。</li></ul><h2 id=\"临时表\"><a href=\"#临时表\" class=\"headerlink\" title=\"临时表\"></a>临时表</h2><h3 id=\"MySQL-默认外部临时表\"><a href=\"#MySQL-默认外部临时表\" class=\"headerlink\" title=\"MySQL 默认外部临时表\"></a><strong>MySQL</strong> 默认外部临时表</h3><ul><li><p><strong>MySQL</strong> 临时表在我们需要保存一些临时数据时是非常有用的，主要用于对大数据量的表上作一个子集，提高查询效率。临时表只在当前连接可见，当关闭连接时，<strong>Mysql</strong> 会自动删除表并释放所有空间。 <strong>PHP</strong> 方式调用 <strong>MySQL</strong> 时，脚本结束之后临时表就被销毁了，其他情况都是在客户端链接关闭之后才会销毁，当然也可以手动销毁。</p></li><li><p>使用方式和普通表类似，不过还是有一些区别的：</p><ul><li><p>创建临时表的时候加上 <strong>TEMPORARY</strong>。</p><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TEMPORARY</span> <span class=\"keyword\">TABLE</span> 表名()</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 <strong>SHOW TABLES</strong> 命令是看不到创建的临时表的。</p></li><li><p>使用 <strong>SHOW CREATE TABLE</strong> 可以查看临时表。</p></li><li><p>在 <strong>information_schema</strong> 中也不存在临时表的信息。</p></li><li><p>退出 <strong>mysql</strong> 连接之后再登陆进去时，临时表已经被销毁了。</p><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql>  SELECT * FROM 表名; # ERROR 1146: Table '表名' doesn't exist</span><br></pre></td></tr></tbody></table></figure></li><li><p>或者使用 <strong>DROP 表名</strong> 来手动销毁临时表也一样。</p><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql>  DROP TABLE 表名;</span><br><span class=\"line\">mysql>  SELECT * FROM 表名; # ERROR 1146: Table '表名' doesn't exist</span><br></pre></td></tr></tbody></table></figure></li><li><p>不同连接的临时表所属各自的作用域，所以不用担心表名重复，如果同一个连接中的临时表和正常表名称相同，则正常表隐藏，临时表将会覆盖掉它。</p></li><li><p>创建临时表不会引发通常的 <strong>COMMIT</strong> 事务提交。</p></li><li><p>临时表不支持 <strong>MySQL</strong> 的集群。</p></li><li><p>临时表不能使用 <strong>RENAME</strong> 来重命名，只能用 <strong>ALTER TABLE 表名1 表名2</strong> 这种形式。</p></li><li><p>同一个查询语句中同一个临时表只能引用一次，但是可以有多个不同的临时表。</p></li><li><p>同一个用户存储函数中同一个临时表也只能引用一次。</p></li><li><p>会对 <strong>MySQL</strong> 的主从复制有一定的影响。</p></li><li><p>临时表的引擎类型只能是：<strong>MEMORY（HEAP）</strong>，<strong>MYISAM</strong>，<strong>MERGE</strong>，<strong>INNODB</strong></p></li></ul></li></ul><h3 id=\"外部内存表\"><a href=\"#外部内存表\" class=\"headerlink\" title=\"外部内存表\"></a>外部内存表</h3><ul><li>在创建临时表时声明引擎类型为 <strong>MEMORY（HEAP）</strong> ，则 <strong>MySQL</strong> 会在内存中创建该临时表，即内存表。</li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TEMPORARY</span> <span class=\"keyword\">TABLE</span> 表名 (...) <span class=\"keyword\">TYPE</span> = <span class=\"keyword\">HEAP</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>内存表的 <strong>MEMORY（HEAP）</strong> 引擎不支持 <strong>BLOB/TEXT</strong> 数据类型的字段。</p></li><li><p>临时表的表和数据都存储在内存中，而内存表的表建在磁盘中而数据存储在内存中。</p></li><li><p>内存表和临时表的容量大小都可以在 <strong>MySQL</strong> 的配置中设置，当内存表的数据使用超出容量时会报错，临时表则会把数据写入到磁盘中，此时需要大量的 <strong>I/O</strong> 操作，引起性能的下降。</p></li><li><p>临时表一般比较少用，一般只在确定不能用索引的时候或者在存储过程中某些固定数据使用次数非常多的时候使用临时表。通常是在应用程序中动态创建或者由 <strong>MySQL</strong> 内部根据执行计划需要自己创建。内存表则大多作为 <strong>Cache</strong> 来使用。如今随着 <strong>memcache</strong> ，<strong>redis</strong> 等第三方 <strong>Cache</strong> 的流行，越来越少选择使用内存表。</p></li></ul><h3 id=\"内部临时表\"><a href=\"#内部临时表\" class=\"headerlink\" title=\"内部临时表\"></a>内部临时表</h3><ul><li><p>在某些情况下，<strong>MySQL</strong> 服务器会自动创建内部临时表。使用 <strong>EXPLAIN</strong> 查看查询语句的执行计划，如果 <strong>extra</strong> 列显示 <strong>“using temporary”</strong> 即使用了内部临时表。</p></li><li><p>内部临时表的创建条件：</p><ul><li><p><strong>UNION</strong> 查询。</p></li><li><p>用到 <strong>TEMPTABLE</strong> 算法或者是 <strong>UNION</strong> 查询中的视图。</p></li><li><p><strong>ORDER BY</strong> 和 <strong>GROUP BY</strong> 的子句不一样时。</p></li><li><p>表连接中 <strong>ORDER BY</strong> 的列不是驱动表中的时候。</p></li><li><p><strong>DISTINCT</strong> 查询并且加上 <strong>ORDER BY</strong> 时。</p></li><li><p><strong>SQL</strong> 中用到 <strong>SQL_SMALL_RESULT</strong> 选项时。</p></li><li><p><strong>FROM</strong> 中的子查询。</p></li></ul></li></ul><h2 id=\"用户设置\"><a href=\"#用户设置\" class=\"headerlink\" title=\"用户设置\"></a>用户设置</h2><h3 id=\"添加用户\"><a href=\"#添加用户\" class=\"headerlink\" title=\"添加用户\"></a>添加用户</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span> </span><br><span class=\"line\">\t(host, <span class=\"keyword\">user</span>, <span class=\"keyword\">password</span>, </span><br><span class=\"line\">\tselect_priv, insert_priv, update_priv) </span><br><span class=\"line\">\t<span class=\"keyword\">VALUES</span> (<span class=\"string\">'localhost'</span>, <span class=\"string\">'guest'</span>, </span><br><span class=\"line\">\t<span class=\"keyword\">PASSWORD</span>(<span class=\"string\">'123'</span>), <span class=\"string\">'Y'</span>, <span class=\"string\">'Y'</span>, <span class=\"string\">'Y'</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li><p>在 <strong>5.7</strong> 版本中 <strong>user</strong> 表的 <strong>password</strong> 字段已换成了 <strong>authentication_string</strong>。</p></li><li><p>使用 <strong>MySQL</strong> 自带的 <strong>PASSWORD()</strong> 函数来对密码进行加密。</p></li><li><p>在 <strong>8.0</strong> 版本中 <strong>PASSWORD()</strong> 加密函数已经移除了，可以使用自带的 <strong>MD5()</strong> 函数代替。</p></li><li><p>执行完之后得执行 <strong>FLUSH PRIVILEGES</strong> ，这个命令执行后会重新载入授权表。如果你不使用该命令就无法使用新创建的用户来连接 <strong>MySQL</strong> 服务器，除非重启。</p></li><li><p>可以在创建用户时为用户指定权限，例如上述代码中的 <strong>select_priv</strong>，<strong>insert_priv</strong>，<strong>update_priv</strong> 字段，在对应的权限列中，在插入语句中设置为 <strong>‘Y’</strong> 即可，用户权限列表如下：</p><ul><li><p>Select_priv</p></li><li><p>Insert_priv</p></li><li><p>Update_priv</p></li><li><p>Delete_priv</p></li><li><p>Create_priv</p></li><li><p>Drop_priv</p></li><li><p>Reload_priv</p></li><li><p>Shutdown_priv</p></li><li><p>Process_priv</p></li><li><p>File_priv</p></li><li><p>Grant_priv</p></li><li><p>References_priv</p></li><li><p>Index_priv</p></li><li><p>Alter_priv</p></li></ul></li></ul><h3 id=\"增删改查操作类似，都是对-user-表进行-INSERT，DELETE，UPDATE，SELECT-这些操作。\"><a href=\"#增删改查操作类似，都是对-user-表进行-INSERT，DELETE，UPDATE，SELECT-这些操作。\" class=\"headerlink\" title=\"增删改查操作类似，都是对 user 表进行 INSERT，DELETE，UPDATE，SELECT 这些操作。\"></a>增删改查操作类似，都是对 <strong>user</strong> 表进行 <strong>INSERT</strong>，<strong>DELETE</strong>，<strong>UPDATE</strong>，<strong>SELECT</strong> 这些操作。</h3><h2 id=\"查看-MySQL-常用信息\"><a href=\"#查看-MySQL-常用信息\" class=\"headerlink\" title=\"查看 MySQL 常用信息\"></a>查看 <strong>MySQL</strong> 常用信息</h2><h3 id=\"查看数据库列表\"><a href=\"#查看数据库列表\" class=\"headerlink\" title=\"查看数据库列表\"></a>查看数据库列表</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">DATABASES</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id=\"查看数据表列表\"><a href=\"#查看数据表列表\" class=\"headerlink\" title=\"查看数据表列表\"></a>查看数据表列表</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">TABLES</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id=\"查看数据表列表-1\"><a href=\"#查看数据表列表-1\" class=\"headerlink\" title=\"查看数据表列表\"></a>查看数据表列表</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">TABLES</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id=\"查看数据表属性\"><a href=\"#查看数据表属性\" class=\"headerlink\" title=\"查看数据表属性\"></a>查看数据表属性</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">COLUMNS</span> <span class=\"keyword\">FROM</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id=\"查看数据表索引信息\"><a href=\"#查看数据表索引信息\" class=\"headerlink\" title=\"查看数据表索引信息\"></a>查看数据表索引信息</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">FROM</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id=\"查看数据库的性能及统计信息\"><a href=\"#查看数据库的性能及统计信息\" class=\"headerlink\" title=\"查看数据库的性能及统计信息\"></a>查看数据库的性能及统计信息</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">STATUS</span> <span class=\"keyword\">FROM</span> 数据库名;</span><br></pre></td></tr></tbody></table></figure><h2 id=\"时间数据类型\"><a href=\"#时间数据类型\" class=\"headerlink\" title=\"时间数据类型\"></a>时间数据类型</h2><ul><li><p><strong>TIMESTAMP</strong> 把客户端插入的时间从当前时区转化为 <strong>UTC</strong>（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而 <strong>DATETIME</strong> 不做任何改变，基本上是原样输入和输出。所以对于跨时区的业务，<strong>TIMESTAMP</strong> 更为合适。</p></li><li><p><strong>TIMESTAMP</strong> 比 <strong>DATETIME</strong> 存储时间范围要小得多。</p></li><li><p><strong>5.6</strong> 及之前版本只有 <strong>TIMESTAMP</strong> 支持默认初始化当前时间及自动更新，且一张表中只支持一个字段，到了 <strong>5.7</strong> 及之后版本 <strong>TIMESTAMP</strong> 和 <strong>DATETIME</strong> 都支持且没有数量限制。</p></li></ul><h2 id=\"LIKE-模糊查询\"><a href=\"#LIKE-模糊查询\" class=\"headerlink\" title=\"LIKE 模糊查询\"></a><strong>LIKE</strong> 模糊查询</h2><ul><li><p>不加任何匹配的话就等价于 <strong>=</strong>。</p></li><li><p><strong>%</strong> 通配符表示任何字符出现任意次，可以是 <strong>0</strong> 次。</p></li><li><p><strong>_</strong> 通配符表示任何字符出现 <strong>1</strong> 次。</p></li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'test%'</span>; <span class=\"comment\"># 以 test 字符串开头的，包括 test 本身，这种方式可以走索引</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'%test'</span>; <span class=\"comment\"># 以 test 字符串结尾的，包括 test 本身</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'%test%'</span>; <span class=\"comment\"># 包含 test 字符串的，包括 test 本身</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'test_'</span>; <span class=\"comment\"># 以 test 字符串开头的，且后面必须跟着一个字符，这种方式可以走索引</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'_test'</span>; <span class=\"comment\"># 以 test 字符串结尾的，且前面必须跟着一个字符</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'_test_'</span>; <span class=\"comment\"># 包含 test 字符串的，且前面和后面必须分别跟着一个字符</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'%[a-z]%'</span>; <span class=\"comment\"># 包含小写字母的</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username <span class=\"keyword\">LIKE</span> <span class=\"string\">'%[!0-9]%'</span>; <span class=\"comment\"># 不包含数字的</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>注意空格也会被识别出来，但是不能匹配 <strong>NULL</strong>。</p></li><li><p>是否区分大小写这个得看 <strong>MySQL</strong> 的配置，或者使用 <strong>BINARY</strong> 操作符来进行二进制的匹配。或者使用 <strong>UPPER</strong> 操作符全部转化成大写字母，然后配合 <strong>CONCAT</strong> 操作符将多个字符串连起来。</p></li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 中英文混合且忽略英文大小写的模糊匹配</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> username <span class=\"keyword\">WHERE</span> <span class=\"keyword\">UPPER</span>(username) <span class=\"keyword\">LIKE</span> <span class=\"built_in\">BINARY</span> <span class=\"keyword\">CONCAT</span>(<span class=\"string\">'%'</span>,<span class=\"keyword\">UPPER</span>(‘a中文b’)，‘%’);</span><br></pre></td></tr></tbody></table></figure><ul><li>当</li></ul></body></html>","prev":{"title":"那些年碰到的神级sql","slug":"那些年碰到的神级sql"},"link":"/post/mysql查漏补缺/","toc":[{"title":"","id":"LIKE-模糊查询","index":"1"}],"reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/mysql查漏补缺/\" title=\"mysql查漏补缺\">/post/mysql查漏补缺/</a>"}}
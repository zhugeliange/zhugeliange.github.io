{"title":"typescript知识点","date":"2021-01-19T03:12:43.000Z","slug":"typeScript知识点","comments":true,"tags":["typescript","前端","知识点"],"categories":["javascript"],"updated":"2021-01-19T03:28:14.000Z","content":"<html><head></head><body><ul><li><p>数组array类型只能为一种。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这三种声明数组的方式等价</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a : number[] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> b : <span class=\"built_in\">Array</span><number> = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</number></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]; <span class=\"comment\">// 隐式声明</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>元组tuple类型可以有多种，固定长度固定类型，声明时需要显式指定类型，不然就只是联合类型。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"string\">'2'</span>]; <span class=\"comment\">// 这种隐式声明并不是元组tuple，而是联合类型(number | string)[]，隐式声明默认取最小能包含变量的类型范围</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b : any[] = [<span class=\"number\">1</span>,<span class=\"string\">'2'</span>]; <span class=\"comment\">// 这个是元组tuple，因为可以包含任意类型的元素</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项，且元素与声明的类型一一对应。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : [number,string];</span><br><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]; <span class=\"comment\">// 元素类型应该和声明的一一对应</span></span><br><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"string\">'b'</span>]; <span class=\"comment\">// 正确</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>元组虽然固定长度，但是也可以越界添加元素，不过添加的元素类型为声明时的联合类型。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : [number,string];</span><br><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"string\">'b'</span>];</span><br><span class=\"line\">a.push(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">a.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">a.push(<span class=\"literal\">true</span>); <span class=\"comment\">// 错误，因为声明时只有number和string类型</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>联合类型union既可以指定多个类型也可以指定多个确定的值，这也就是字面量类型literal。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : number | string; <span class=\"comment\">// 联合类型，值可以为数字或者字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b : <span class=\"number\">1</span> | <span class=\"string\">'2'</span> | <span class=\"literal\">true</span> | [<span class=\"number\">1</span>,<span class=\"number\">2</span>]; <span class=\"comment\">// 值只能为1，'2'，true，[1,2]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>枚举类型enum的值默认为索引数字，后面依次+1，也可以手动指定值，类型为数字或者字符串，如果是被赋值为字符串，则其后面的元素必须再次手动赋值，直到为数字为止</p></li><li>其内部是一组类似于数组的键值对，如果值为数字类型还会默认添加一组键值对互换的值，所以可以按照数组的方式来访问。且元素为只读属性，不可以再另外赋值。</li><li><p>可以包含计算元素，但是其后面不能使用值默认的自动推断，必须手动复赋值。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum a { <span class=\"comment\">// 声明时前面不用加let</span></span><br><span class=\"line\">\tred, <span class=\"comment\">// 值为0</span></span><br><span class=\"line\">\tgreen, <span class=\"comment\">// 值为1</span></span><br><span class=\"line\">\tblue <span class=\"comment\">// 值为2</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 完整值为 { '0': 'red', '1': 'green', '2': 'blue', red: 0, green: 1, blue: 2 }，所以a.red或者a['red']为0，a[0]或者a['0']为red</span></span><br><span class=\"line\"></span><br><span class=\"line\">enum b {</span><br><span class=\"line\">\tred, <span class=\"comment\">// 值为0</span></span><br><span class=\"line\">\tgreen = <span class=\"number\">2</span>, <span class=\"comment\">// 值为2</span></span><br><span class=\"line\">\tblue <span class=\"comment\">// 值为3</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完整值为 { '0': 'red', '2': 'green', '3': 'blue', red: 0, green: 2, blue: 3 }，所以b.green或者b['green']为2，b[2]或者b['2']为green</span></span><br><span class=\"line\"></span><br><span class=\"line\">enum c {</span><br><span class=\"line\">\tred, <span class=\"comment\">// 值为0</span></span><br><span class=\"line\">\tgreen = <span class=\"string\">'hehe'</span>, <span class=\"comment\">// 值为hehe</span></span><br><span class=\"line\">\tblue = <span class=\"number\">6</span> <span class=\"comment\">// 必须再次手动赋值</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 完整值为 { '0': 'red', '6': 'blue', red: 0, green: 'hehe', blue: 6 }，所以c.green或者c['green']为hehe，c[6]或者c['6']为blue</span></span><br><span class=\"line\"></span><br><span class=\"line\">enum d {</span><br><span class=\"line\">\tred,</span><br><span class=\"line\">\tgreen = <span class=\"string\">'green'</span>.length,</span><br><span class=\"line\">\tblue = <span class=\"number\">2</span> <span class=\"comment\">// 这里必须手动赋值，因为不确定上一个元素的值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>常数枚举使用const enum定义，与普通枚举的区别是，它会在编译阶段被删除，在编译生成的js中直接使用元素的值，并且不能包含计算成员。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> enum Directions {</span><br><span class=\"line\">    Up,</span><br><span class=\"line\">    Down,</span><br><span class=\"line\">    Left,</span><br><span class=\"line\">    Right</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class=\"line\"><span class=\"comment\">// 编译结果是</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> directions = [<span class=\"number\">0</span> <span class=\"comment\">/* Up */</span>, <span class=\"number\">1</span> <span class=\"comment\">/* Down */</span>, <span class=\"number\">2</span> <span class=\"comment\">/* Left */</span>, <span class=\"number\">3</span> <span class=\"comment\">/* Right */</span>];</span><br></pre></td></tr></tbody></table></figure></li><li><p>外部枚举使用declare enum定义，与普通枚举的区别是，它只会用于编译时的检查，编译生成的js文件中会被删除，所以常用在声明文件里面用来做类型检查。</p></li><li><p>unknown类型是any类型的安全版本，因为需要更多的类型断言，unknown类型是所有类型的顶层类型，但是还保留了类型检查，而any类型既是所有类型的顶层类型同时也放弃了类型检查，原则上优先使用unknown类型。</p></li><li><p>void类型表示不存在，例如函数没有返回值，而undefined类型则表示没有值，例如变量声明了但是没有赋值。never类型表示函数永远不会执行完，例如抛出异常或者死循环。</p></li><li><p>类型断言type assertions，表示手动指定变量的类型。强制转换指的是改变类型，而类型断言则指的是指定某些个大类型之中的小类型，比如any中的number。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : any; </span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = (<number>a)++; // 值为2，将any类型断言为number类型，但是这种尖括号方式在react中可能会引起歧义，所以改用下面的方式</number></span><br><span class=\"line\">let c = (a as number)++; // 值为3</span><br><span class=\"line\"></span><br><span class=\"line\">let a : any; </span><br><span class=\"line\">a = 1;</span><br><span class=\"line\">let b = (<number | string>a) + '1'; // 值为11</number></span><br><span class=\"line\">let c = (a as number | string) + '1';  // 值为11</span><br><span class=\"line\"></span><br><span class=\"line\">let a : any; </span><br><span class=\"line\">a = '1';</span><br><span class=\"line\">let b = (<string>a).length; // 值为1</string></span><br><span class=\"line\">let c = (a as string).length;  // 值为1</span><br></pre></td></tr></tbody></table></figure></li><li><p>函数的可选参数或者默认参数都要放在末尾。</p></li><li><p>0x开头表示二进制，0b开头表示八进制。</p></li><li><p>可以使用null和undefined来定义这两个原始数据类型。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>undefined和null是所有类型的子类型，可以赋值给其他类型的变量。而void类型的变量不可以，且只能赋值为undefined，虽然这样并没有意义。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样不会报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: number = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这样也不会报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b: number = a;</span><br><span class=\"line\"><span class=\"comment\">// void类型的变量不可以</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"keyword\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b: number = a;</span><br></pre></td></tr></tbody></table></figure></li><li><p>类型别名用来给一个类型起个新名字，常用于联合类型。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type a = string;</span><br><span class=\"line\">type b = <span class=\"function\"><span class=\"params\">()</span> =></span> string;</span><br><span class=\"line\">type c = a | b;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">d: c</span>): <span class=\"title\">a</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> d === <span class=\"string\">'string'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> haha = (e : string) : <span class=\"function\"><span class=\"params\">string</span> =></span> {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">getName(<span class=\"string\">'hehe'</span>); <span class=\"comment\">// 输出hehe</span></span><br><span class=\"line\"></span><br><span class=\"line\">getName(haha(<span class=\"string\">'haha'</span>)); <span class=\"comment\">// 输出haha</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>{</span><br><span class=\"line\">  public <span class=\"keyword\">constructor</span>(public a: string) {</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>{</span><br><span class=\"line\">  public a: string;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(a) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>readonly只允许出现在属性声明或索引签名或构造函数中，如果和其他访问修饰符同时存在的话，需要写在其后面。</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>{</span><br><span class=\"line\">  readonly a: string;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(a) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>{</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(public readonly b) {</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li></ul></body></html>","prev":{"title":"react知识点","slug":"react知识点"},"next":{"title":"目前最好的白嫖图床方案","slug":"目前最好的白嫖图床方案"},"link":"/post/typeScript知识点/","reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/typeScript知识点/\" title=\"typescript知识点\">/post/typeScript知识点/</a>"}}
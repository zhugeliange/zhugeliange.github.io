{"title":"mysql性能调优","date":"2017-06-28T05:19:13.000Z","slug":"mysql性能调优","comments":true,"tags":["mysql","性能","调优"],"categories":["mysql"],"updated":"2019-03-28T10:39:14.034Z","content":"<html><head></head><body><ul><li><p>适当地使用索引，索引可以优化查询效率，但是过多的话影响修改效率。</p></li><li><p>使用复合索引，优先级从左到右。</p></li><li><p>坚决不要涉及到 <strong>NULL</strong> 值，因为 <strong>NULL</strong> 值不会走索引。</p></li><li><p><strong>MySQL</strong> 的一条查询只能使用一个索引，例如：当 <strong>WHERE</strong> 条件使用索引时，后面 <strong>ORDER BY</strong> 的索引将不会使用。</p></li><li><p>尽量避免模糊查询，因为 <strong>%value%</strong> 不会走索引，但是 <strong>value%</strong> 可以用索引。实在需要 <strong>%value</strong> 这种形式可以在使用符合索引构成覆盖索引，性能至少会比全表扫描好。或者根据需求拆成多次查询。</p></li><li><p>不要使用 <strong>非操作</strong>， 诸如 <strong>NOT</strong>， <strong><></strong>, <strong>!=</strong> 这些操作是不会走索引的。</p></li><li><p>不要在 <strong>WHERE子句</strong> 中的 <strong>=</strong> 左边进行任何操作，诸如 <strong>WHERE YEAR(birthday) < 2017</strong> 这样的操作是不会走索引的。</p></li><li><p>多个条件时慎用 <strong>OR</strong> ， 当一个条件有索引而另一个没有时，就不会走索引了，可以分别查询然后用 <strong>UNION</strong> 将结果集连接起来。</p></li><li><p>用 <strong>EXISTS</strong> 代替 <strong>IN</strong>，前者效率比较高。</p></li><li><p>字段类型越简单查询效率越高，例如：主键是 <strong>int</strong> 类型就比 <strong>char</strong> 类型快很多。</p></li><li><p><strong>nvarchar</strong> 相比 <strong>varchar</strong> 可以存储 <strong>unicode</strong> 字符，但是也因此存储容量少了一半，同理 <strong>nchar</strong> 对比 <strong>char</strong>。</p></li><li><p><strong>nvarchar/varchar</strong> 相比 <strong>nchar/char</strong> 字符是不固定长度的，因此从占用空间上来考虑会比较高效，但是正因为 <strong>nchar/char</strong> 是固定长度的所以索引效率会比较高，这个得根据实际情况来考虑平衡。</p></li><li><p>绝对不要用 <strong>*</strong> ，除非真的要查全部数据，否则每条 <strong>SQL</strong> 都应该只查询需要的数据，不应该有任何的多余字段。</p></li><li><p>尽量使用 <strong>表变量</strong> 来代替 <strong>临时表</strong>。如果 <strong>表变量</strong> 包含大量数据，请注意索引非常有限（只有主键索引），且 <strong>mysql</strong> 中只有 <strong>临时表</strong> 没有 <strong>表变量</strong>。</p></li><li><p>避免频繁创建和删除 <strong>临时表</strong>，以减少系统表资源的消耗。<strong>临时表</strong> 并不是不可使用，适当地使用它们可以使某些例程更有效，例如：当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p></li><li><p>在新建 <strong>临时表</strong> 时，如果一次性插入数据量很大，那么可以使用 <strong>SELECT INTO</strong> 代替 <strong>CREATE TABLE</strong>，避免造成大量 <strong>log</strong> ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 <strong>CREATE TABLE</strong>，然后 <strong>INSERT</strong>。</p></li><li><p>如果使用到了 <strong>临时表</strong> ，在存储过程的最后务必将所有的 <strong>临时表</strong> 显式删除，先 <strong>TRUNCATE TABLE</strong> ，然后 <strong>DROP TABLE</strong> ，这样可以避免系统表的较长时间锁定。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。</p></li></ul><ol start=\"18\"><li><p>拆分大的 <strong>DELETE</strong> 或 <strong>INSERT</strong> 语句为小的语句，批量提交 <strong>SQL</strong> 语句。因为删除和更新操作会锁表，当数据量过大耗时太久时，很可能会造成服务的崩溃。</p></li><li><p>用 <strong>JOIN</strong> 代替 <strong>子查询</strong>。</p></li><li><p>用 <strong>UNION</strong> 代替 <strong>临时表</strong>。</p></li><li><p>使用 <strong>外键</strong> 来保证数据的同步。</p></li><li><p>数据库的解析器按照从右到左的顺序处理 <strong>FROM</strong> 子句中的表名， <strong>FROM</strong> 子句中写在最后的表将被最先处理，在 <strong>FROM</strong> 子句中包含多个表的情况下,你必须选择记录条数最少的表放在最后：如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推，如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。</p></li><li><p>数据库采用自右而左的顺序解析 <strong>WHERE</strong> 子句，根据这个原理，过滤掉大量数据的条件应该放在最右边，表之间的连接应该放在最左边。</p></li><li><p>用 <strong>WHERE</strong> 子句替换 <strong>HAVING</strong> 子句，因为 <strong>WHERE</strong> 先执行，<strong>HAVING</strong> 后执行。</p></li><li><p>使用 <strong>>=</strong> 代替 <strong>></strong> ，例如：<strong>WHERE a > 10</strong> 改成 <strong>WHERE a > 10.0000001</strong>。</p></li><li><p>删除全表时，用 <strong>TRUNCATE</strong> 而不用 <strong>DELETE</strong>。</p></li><li><p>尽量多使用 <strong>COMMIT</strong>，只要有可能就对程序中每个 <strong>DELETE</strong>，<strong>INSERT</strong>，<strong>UPDATE</strong> 使用 <strong>COMMIT</strong>，这样系统会因为 <strong>COMMIT</strong> 所释放的资源而大大提高效率。</p></li><li><p>有条件的使用 <strong>UNION ALL</strong> 代替 <strong>UNION</strong> 提高效率。这两者的唯一区别就是后者会去除重复的值。</p></li><li><p>当连接多个表时，对表使用别名，子查询也是如此，因为这样可以加快数据库引擎查找表的时间。</p></li><li><p>最高效的删除重复记录方法例子： <strong>DELETE FROM table1 a WHERE a.field > (SELECT MIN(b.field) FROM table2 b WHERE b.id = a.id)</strong>;</p></li><li><p>尽量少用 <strong>联合查询JOIN</strong>， <strong>子查询</strong>， <strong>触发器</strong>， <strong>事务</strong> 这些相对复杂的操作，数据库设计时尽量做到能用最简单的语句来完成查询。</p></li></ol></body></html>","next":{"title":"mysql高可用架构设计","slug":"mysql高可用架构设计"},"link":"/post/mysql性能调优/","reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/mysql性能调优/\" title=\"mysql性能调优\">/post/mysql性能调优/</a>"}}
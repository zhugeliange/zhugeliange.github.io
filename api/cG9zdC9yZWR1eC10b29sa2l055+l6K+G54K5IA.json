{"title":"redux-toolkit知识点","date":"2021-05-23T06:10:44.000Z","slug":"redux-toolkit知识点 ","comments":true,"tags":["RTK-query","react","redux","redux-toolkit"],"categories":["前端"],"updated":"2021-05-24T02:24:15.000Z","content":"<html><head></head><body><h4 id=\"首先理解redux\"><a href=\"#首先理解redux\" class=\"headerlink\" title=\"首先理解redux\"></a>首先理解redux</h4><ul><li><p>所谓 Redux，就是将动作(action) 变换成 state 转换函数(reducer)，然后放到一个统一的地方(store)来 setState 而已。</p></li><li><p>特性有3个：</p><ul><li>单向性：单向数据流其实并不是redux的特性，而是react本身的思想。这个下面有例子会说明。</li><li>唯一性：指的是应用的数据都会集中存储在一个地方，这个数据Store就像一个池子，任何组件都可以通过固定的管道来传输或者获取这个池子里面的数据</li><li>时间旅行：这个“时间旅行”另外的意思是可预测（predictable），即容易理解的代码。在redux里，任何一个数据都有状态。一个用户操作或者程序需要去修改数据，都必须触发Action，这时在redux看来，其实数据是从一个状态，变化成另一个状态。这么一来，数据就变得可预测，可以知道数据的前置状态(prev state)和后置状态(next state)分别是什么，如果在这里加上单元测试，也是极其容易的一件事情。</li></ul></li><li><p>这意味着你必须遵循一定的规则才可以让你的程序走通。所以实现一个功能通常的得相应的创建三个文件：Action，Reducer，Store，同时也是Redux最重要的3个概念。当然有了redux-toolkit之后这些都可以简化了，这个后面说。</p></li><li><p>Action：一言蔽之就是指的用户的一个行为，例如，click，hover，input等。并通过Dispatch将这个行为通知给Store。</p></li><li><p>Reducer：Store内部有很多个Reducer，用来接收Action，并将Store的某些State做相应的更新，同时出发View的更新。</p></li><li><p>Store：作为一个总的容器来管理以上发生的行为及相关的数据。</p></li></ul><h4 id=\"开始使用redux-toolkit\"><a href=\"#开始使用redux-toolkit\" class=\"headerlink\" title=\"开始使用redux-toolkit\"></a>开始使用redux-toolkit</h4><ul><li><p>redux的毛病就是配置太过繁琐，有大量的冗余，且对异步请求支持不是很好。</p></li><li><p>redux-toolkit实际上就是一些redux相关的工具集：</p><ul><li>configureStore(): 包装 createStore 以提供简化的配置选项和良好的默认预设。它可以自动组合你的切片 reducers，添加您提供的任何 Redux 中间件，默认情况下包含 redux-thunk ，并允许使用 Redux DevTools 扩展。</li><li>createReducer(): 为 case reducer 函数提供 action 类型的查找表，而不是编写switch语句。此外，它会自动使用immer库来让您使用普通的可变代码编写更简单的 immutable 更新，例如 state.todos [3] .completed = true 。</li><li>createAction(): 为给定的 action type string 生成一个 action creator 函数。函数本身定义了 toString()，因此它可以用来代替 type 常量。</li><li>createSlice(): 接受一个 reducer 函数的对象、分片名称和初始状态值，并且自动生成具有相应 action creators 和 action 类型的分片reducer。</li><li>createAsyncThunk: 接受一个 action type string 和一个返回 promise 的函数，并生成一个发起基于该 promise 的pending/fulfilled/rejected action 类型的 thunk。</li><li>createEntityAdapter: 生成一组可重用的 reducers 和 selectors，以管理存储中的规范化数据</li><li>createSelector 组件 来自 Reselect 库，为了易用再导出。</li></ul></li><li><p>除此之外，新版redux-toolkit还提供了RTK-query用来专门处理异步请求。比fetch，axios，react query方案都更好，具体好在哪里，请自行谷歌～</p></li><li><p>按我个人经验，分享一个使用redux-toolkit的最佳实践：</p><ul><li>在入口文件app.tsx引入Provider组件并放在最外层，加一个store属性，值可以单独写一个store.ts配置文件来引入。</li><li>在store.ts配置文件里面用configureStore方法做全局状态的唯一容器，然后export出去。</li><li>创建一个rootReducer.ts文件，然后里面用combineReducers方法组合所有的reducer，然后export出去交给store.ts来管理。</li><li>然后就是根据项目的特性依次创建相应的Slice切片，如果是本地状态，就用createSlice方法集成state，reducer。如果是异步的请求，可以用createAsyncThunk也可以RTK-query来处理，个人推荐后者。</li><li>如果是react16之后的版本使用hook方式的话还可以将useSelect方法和useDispatch做个简单的封装，以供全局使用。</li></ul></li></ul></body></html>","prev":{"title":"程序员必知必会的几种基础算法","slug":"程序员必知必会的几种基础算法"},"next":{"title":"ant-design知识点","slug":"ant-desgin知识点"},"link":"/post/redux-toolkit知识点 /","reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/redux-toolkit知识点 /\" title=\"redux-toolkit知识点\">/post/redux-toolkit知识点 /</a>"}}
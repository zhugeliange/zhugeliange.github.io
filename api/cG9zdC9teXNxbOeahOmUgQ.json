{"title":"mysql的锁","date":"2017-12-02T08:07:15.000Z","slug":"mysql的锁","comments":true,"tags":["mysql","锁"],"categories":["mysql"],"updated":"2019-04-03T08:07:15.000Z","content":"<html><head></head><body><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul><li><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p></li><li><p>锁保证数据并发访问的一致性、有效性。</p></li><li><p>锁冲突也是影响数据库并发访问性能的一个重要因素。</p></li><li><p>锁是 <strong>MySQL</strong> 在服务器层和存储引擎层的的并发控制。</p></li><li><p>加锁是消耗资源的，锁的各种操作包括：获得锁、检测锁是否是否已解除、释放锁等。</p></li></ul><h2 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h2><ul><li><p><strong>共享锁（读锁）：</strong> 其他事务可以读，但不能写。</p></li><li><p><strong>排他锁（写锁）：</strong> 其他事务不能读取，也不能写。</p></li></ul><h2 id=\"粒度锁\"><a href=\"#粒度锁\" class=\"headerlink\" title=\"粒度锁\"></a>粒度锁</h2><ul><li><p><strong>MySQL</strong> 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p><ul><li><p><strong>MyISAM</strong> 和 <strong>MEMORY（HEAP）</strong> 存储引擎采用的是表级锁（<strong>table-level locking</strong>）。</p></li><li><p><strong>BDB</strong> 存储引擎采用的是页面锁（<strong>page-level locking</strong>），但也支持表级锁。</p></li><li><p><strong>InnoDB</strong> 存储引擎既支持行级锁（<strong>row-level locking</strong>），也支持表级锁，但默认情况下是采用行级锁。</p></li></ul></li><li><p>默认情况下，表锁和行锁都是自动获得的不需要额外的命令。但是在有的情况下，用户需要明确地进行锁表或者进行事务的控制以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p></li></ul><h3 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h3><ul><li><p>开销小，加锁快，不会出现死锁。</p></li><li><p>锁定粒度大，发生锁冲突的概率最高，并发度最低。</p></li><li><p>存储引擎通过总是一次性同时获取所有需要的锁并且总是按相同的顺序获取表级锁来避免死锁。</p></li><li><p>表级锁更适合于以查询为主并发用户少，只有少量按索引条件更新数据的应用，如 <strong>Web</strong> 应用。</p></li></ul><h3 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h3><ul><li><p>开销大，加锁慢，会出现死锁。</p></li><li><p>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li><li><p>最大程度的支持并发，同时也带来了最大的锁开销。</p></li><li><p>在 <strong>InnoDB</strong> 中，除单个 <strong>SQL</strong> 组成的事务外，锁是逐步获得的，这就决定了在 <strong>InnoDB</strong> 中发生死锁是可能的。</p></li><li><p>行级锁只在存储引擎层实现，而 <strong>MySQL</strong> 服务器层没有实现。</p></li><li><p>行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（<strong>OLTP</strong>）系统。</p></li></ul><h3 id=\"页面锁\"><a href=\"#页面锁\" class=\"headerlink\" title=\"页面锁\"></a>页面锁</h3><ul><li><p>开销和加锁时间界于表锁和行锁之间，会出现死锁。</p></li><li><p>锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul><h2 id=\"MyISAM-的表锁\"><a href=\"#MyISAM-的表锁\" class=\"headerlink\" title=\"MyISAM 的表锁\"></a><strong>MyISAM</strong> 的表锁</h2><h3 id=\"MyISAM-表锁模式\"><a href=\"#MyISAM-表锁模式\" class=\"headerlink\" title=\"MyISAM 表锁模式\"></a><strong>MyISAM</strong> 表锁模式</h3><ul><li><p><strong>表共享读锁 （Table Read Lock）：</strong> 不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求。</p></li><li><p><strong>表独占写锁 （Table Write Lock）：</strong> 会阻塞其他用户对同一表的读和写操作。</p></li><li><p><strong>MyISAM</strong> 表的读操作与写操作之间，以及写操作互相之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。 其他线程的读写操作都会等待，直到锁被释放为止。</p></li><li><p>默认情况下，写锁比读锁具有更高的优先级，当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p></li><li><p>这也正是 <strong>MyISAM</strong> 表不太适合于有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时一些需要长时间运行的查询操作，也会使写线程 <strong>饿死</strong>，应用中应尽量避免出现长时间运行的查询操作，在可能的情况下可以将 <strong>SQL</strong> 语句进行拆分，使每一步查询都能在较短时间完成从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p></li><li><p>可以设置改变读锁和写锁的优先级：</p><ul><li><p>通过指定启动参数 <strong>low-priority-updates</strong>，使 <strong>MyISAM</strong> 引擎默认给予读请求以优先的权利。</p></li><li><p>通过执行命令 <strong>SET LOW_PRIORITY_UPDATES=1</strong>，使该连接发出的更新请求优先级降低。</p></li><li><p>通过指定 <strong>INSERT</strong>，<strong>UPDATE</strong>，<strong>DELETE</strong> 语句的 <strong>LOW_PRIORITY</strong> 属性，降低该语句的优先级。</p></li><li><p>给系统参数 <strong>max_write_lock_count</strong> 设置一个合适的值，当一个表的读锁达到这个值后，<strong>MySQL</strong> 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p></li></ul></li></ul><h3 id=\"MyISAM-加表锁的方法\"><a href=\"#MyISAM-加表锁的方法\" class=\"headerlink\" title=\"MyISAM 加表锁的方法\"></a><strong>MyISAM</strong> 加表锁的方法</h3><ul><li><p><strong>MyISAM</strong> 在执行查询语句（<strong>SELECT</strong>）之前，会自动给涉及的表加读锁，在执行更新操作<br>（<strong>UPDATE</strong>，<strong>DELETE</strong>，<strong>INSERT</strong>等）之前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 <strong>LOCK TABLE</strong> 命令给 <strong>MyISAM</strong> 表显式加锁。</p></li><li><p>在自动加锁的情况下，<strong>MyISAM</strong> 总是一次获得 <strong>SQL</strong> 语句所需要的全部锁，这也正是 <strong>MyISAM</strong> 表不会出现死锁（<strong>Deadlock Free</strong>）的原因。</p></li><li><p><strong>MyISAM</strong> 存储引擎支持并发插入，以减少给定表的读和写操作之间的争用，如果 <strong>MyISAM</strong> 表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。在这种情况下，可以自由混合并发使用 <strong>MyISAM</strong> 表的 <strong>INSERT</strong> 和 <strong>SELECT</strong> 语句而不需要加锁，可以在其他线程进行读操作的时候，同时将行插入到 <strong>MyISAM</strong> 表中。文件中间的空闲块可能是从表格中间删除或更新的行而产生的。如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用 <strong>MySQL</strong> 的 <strong>concurrent_insert</strong> 系统变量。</p><ul><li><p>当 <strong>concurrent_insert</strong> 设置为 <strong>0</strong> 时，不允许并发插入。</p></li><li><p>当 <strong>concurrent_insert</strong> 设置为 <strong>1</strong> 时，如果 <strong>MyISAM</strong> 表中没有空洞，即表的中间没有被删除的行，<strong>MyISAM</strong> 允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是 <strong>MySQL</strong> 的默认设置。</p></li><li><p>当 <strong>concurrent_insert</strong> 设置为 <strong>2</strong> 时，无论 <strong>MyISAM</strong> 表中有没有空洞，都允许在表尾并发插入记录。</p></li></ul></li><li><p>如果使用 <strong>LOCK TABLES</strong> 显式获取表锁，则可以请求 <strong>READ LOCAL</strong> 锁而不是 <strong>READ</strong> 锁，以便在锁定表时，其他会话可以使用并发插入。</p></li></ul><h3 id=\"MyISAM-查看表锁的争用情况\"><a href=\"#MyISAM-查看表锁的争用情况\" class=\"headerlink\" title=\"MyISAM 查看表锁的争用情况\"></a><strong>MyISAM</strong> 查看表锁的争用情况</h3><ul><li>可以通过检查 <strong>table_locks_waited</strong> 和 <strong>table_locks_immediate</strong> 状态变量来分析系统上的表锁的争夺，如果 <strong>Table_locks_waited</strong> 的值比较高，则说明存在着较严重的表级锁争用情况。</li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">STATUS</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">'Table%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src=\"https://cdn.jsdelivr.net/gh/hexo/mysql-biaosuo.png?m=webp&q=80\" alt=\"mysql表锁\"></p><h2 id=\"InnoDB-行锁和表锁\"><a href=\"#InnoDB-行锁和表锁\" class=\"headerlink\" title=\"InnoDB 行锁和表锁\"></a><strong>InnoDB</strong> 行锁和表锁</h2><h3 id=\"InnoDB-的锁模式\"><a href=\"#InnoDB-的锁模式\" class=\"headerlink\" title=\"InnoDB 的锁模式\"></a><strong>InnoDB</strong> 的锁模式</h3><ul><li><p><strong>共享锁：</strong> 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p><strong>排他锁：</strong> 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</p></li><li><p>为了允许行锁和表锁共存，实现多粒度锁机制，<strong>InnoDB</strong> 还有两种内部使用的意向锁（<strong>Intention Locks</strong>），这两种意向锁都是表锁：</p><ul><li><p><strong>意向共享锁：</strong> 事务在给一个数据行加共享锁前必须先取得该表的意向共享锁。</p></li><li><p><strong>意向排他锁：</strong> 事务在给一个数据行加排他锁前必须先取得该表的意向排他锁。</p></li></ul></li></ul><ul><li>如果一个事务请求的锁模式与当前的锁兼容，<strong>InnoDB</strong> 就将请求的锁授予该事务，反之不兼容，则该事务就要等待锁释放。锁模式的兼容情况：</li></ul><table><thead><tr><th style=\"text-align:left\">当前锁模式/请求锁模式</th><th style=\"text-align:center\">共享锁</th><th style=\"text-align:center\">排他锁</th><th style=\"text-align:center\">意向共享锁</th><th style=\"text-align:center\">意向排他锁</th></tr></thead><tbody><tr><td style=\"text-align:left\">共享锁</td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td></tr><tr><td style=\"text-align:left\">排他锁</td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td></tr><tr><td style=\"text-align:left\">意向共享锁</td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td></tr><tr><td style=\"text-align:left\">意向排他锁</td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>FALSE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td><td style=\"text-align:center\"><strong>TRUE</strong></td></tr></tbody></table><h3 id=\"InnoDB-加锁的方法\"><a href=\"#InnoDB-加锁的方法\" class=\"headerlink\" title=\"InnoDB 加锁的方法\"></a><strong>InnoDB</strong> 加锁的方法</h3><h4 id=\"隐式锁定\"><a href=\"#隐式锁定\" class=\"headerlink\" title=\"隐式锁定\"></a>隐式锁定</h4><ul><li><p>意向锁是 <strong>InnoDB</strong> 自动加的，不用户干预。</p></li><li><p>对于 <strong>UPDATE</strong>，<strong>DELETE</strong>，<strong>INSERT</strong> 这些更新语句，<strong>InnoDB</strong> 会自动给涉及数据集加排他锁。</p></li><li><p>对于普通 <strong>SELECT</strong> 查询语句，<strong>InnoDB</strong> 不会加任何锁。</p></li><li><p><strong>InnoDB</strong> 在事务执行过程中，随时都可以执行锁定，<strong>InnoDB</strong> 会根据隔离级别在需要的时候自动加锁。</p></li><li><p>锁只有在执行 <strong>COMMIT</strong> 或者 <strong>ROLLBACK</strong> 的时候才会释放，并且所有的锁都是在同一时刻被释放。</p></li></ul><h3 id=\"显式锁定\"><a href=\"#显式锁定\" class=\"headerlink\" title=\"显式锁定\"></a>显式锁定</h3><p>事务可以通过以下语句显式给记录集加共享锁或排他锁。</p><p>共享锁（<strong>IN SHARE MODE</strong>）：</p><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> 表名 <span class=\"keyword\">WHERE</span> 条件 <span class=\"keyword\">LOCK</span> <span class=\"keyword\">IN</span> <span class=\"keyword\">SHARE</span> <span class=\"keyword\">MODE</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>其他 <strong>SESSION</strong> 仍然可以查询记录，并也可以对该记录加 <strong>SHARE MODE</strong> 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</p></li><li><p><strong>IN SHARE MODE</strong> 子句的作用就是将查找到的数据加上一个 <strong>SHARE</strong> 锁，这个就是表示其他的事务只能对这些数据进行简单的 <strong>SELECT</strong> 操作，并不能够进行 <a href=\"https://blog.csdn.net/level_level/article/details/4248685\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DML操作</a>（可以简单理解为增删改查操作）。</p></li><li><p>使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据用 <strong>IN SHARE MODE</strong> 的方式上了共享锁。</p></li><li><p>性能影响：该语句是给查找的数据上一个共享锁的功能，它允许其他的事务也对该数据上共享锁，但是不能够允许对该数据进行修改。如果不及时的 <strong>COMMIT</strong> 或者 <strong>ROLLBACK</strong> 也可能会造成大量的事务等待。</p></li></ul><ul><li>排他锁（<strong>IFOR UPDATE</strong>）：</li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> 表名 <span class=\"keyword\">WHERE</span> 条件 <span class=\"keyword\">FOR</span> <span class=\"keyword\">UPDATE</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>其他 <strong>SESSION</strong> 仍然可以查询记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。</p></li><li><p>在执行这个 <strong>SELECT</strong> 查询语句的时候，会将对应的索引访问条目进行上排他锁，也就是说这个语句对应的锁就相当于 <strong>UPDATE</strong> 带来的效果。</p></li><li><p>使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候。</p></li><li><p>性能影响：该语句相当于一个 <strong>UPDATE</strong> 语句。在业务繁忙的情况下，如果事务没有及时的 <strong>COMMIT</strong> 或者 <strong>ROLLBACK</strong> 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。</p></li></ul><h3 id=\"InnoDB-行锁的实现方式\"><a href=\"#InnoDB-行锁的实现方式\" class=\"headerlink\" title=\"InnoDB 行锁的实现方式\"></a><strong>InnoDB</strong> 行锁的实现方式</h3><ul><li><p><strong>InnoDB</strong> 行锁是通过给索引项加锁来实现的，这种行锁实现特点意味着：只有通过索引条件检索数据，<strong>InnoDB</strong> 才使用行锁，否则将使用表锁。</p></li><li><p>不论是使用主键索引，唯一索引或普通索引，<strong>InnoDB</strong> 都会使用行锁来对数据加锁。</p></li><li><p>只有执行计划真正使用了索引才能使用行锁，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 <strong>MySQL</strong> 通过判断不同执行计划的代价来决定的，如果 <strong>MySQL</strong> 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 <strong>SQL</strong> 的执行计划（可以通过 <strong>EXPLAIN</strong> 检查 <strong>SQL</strong> 的执行计划），以确认是否真正使用了索引。</p></li><li><p>由于 <strong>MySQL</strong> 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个 <strong>SESSION</strong> 是访问不同行的记录，但是如果是使用相同的索引键，还是会出现锁冲突的（后使用这些索引的 <strong>SESSION</strong> 需要等待先使用索引的 <strong>SESSION</strong> 释放锁后，才能获取锁）。</p></li></ul><h3 id=\"InnoDB-查看行锁的争用情况\"><a href=\"#InnoDB-查看行锁的争用情况\" class=\"headerlink\" title=\"InnoDB 查看行锁的争用情况\"></a><strong>InnoDB</strong> 查看行锁的争用情况</h3><ul><li>可以通过检查 <strong>InnoDB_row_lock</strong> 状态变量来分析系统上的行锁的争夺情况：</li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">STATUS</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">'innodb_row_lock%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src=\"https://cdn.jsdelivr.net/gh/hexo/mysql-hangsuo.png?m=webp&q=80\" alt=\"mysql行锁\"></p><h3 id=\"InnoDB-的间隙锁\"><a href=\"#InnoDB-的间隙锁\" class=\"headerlink\" title=\"InnoDB 的间隙锁\"></a><strong>InnoDB</strong> 的间隙锁</h3><ul><li><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，<strong>InnoDB</strong> 会给符合条件的已有数据记录的索引项加锁，键值在条件范围内但并不存在的记录叫做 <strong>间隙</strong>，<strong>InnoDB</strong> 也会对这个 <strong>间隙</strong> 加锁，这种锁机制就是所谓的间隙锁（<strong>Next-Key</strong> 锁）。</p></li><li><p>很显然，在使用范围条件检索并锁定记录时，<strong>InnoDB</strong> 这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p></li><li><p>间隙锁可以防止幻读，数据恢复和主从复制的需要。</p></li><li><p><strong>MySQL</strong> 通过 <strong>BINLOG</strong> 录入执行成功的 <strong>INSERT</strong>，<strong>UPDATE</strong>，<strong>DELETE</strong> 等更新数据的 <strong>SQL</strong> 语句，并由此实现 <strong>MySQL</strong> 数据库的恢复和主从复制。</p></li><li><p><strong>MySQL</strong> 的恢复机制，其实就是在从机器上不断做基于 <strong>BINLOG</strong> 的恢复，有以下特点：</p><ul><li><p><strong>MySQL</strong> 的恢复是 <strong>SQL</strong> 语句级的，也就是重新执行 <strong>BINLOG</strong> 中记录的 <strong>SQL</strong> 语句。</p></li><li><p><strong>MySQL</strong> 的 <strong>BINLOG</strong> 是按照事务提交的先后顺序记录的，因此恢复也是按这个顺序进行的。</p></li></ul></li><li><p>由此可见，<strong>MySQL</strong> 的恢复机制要求：在一个事务未提交之前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p></li></ul><h3 id=\"InnoDB-的主动加表锁\"><a href=\"#InnoDB-的主动加表锁\" class=\"headerlink\" title=\"InnoDB 的主动加表锁\"></a><strong>InnoDB</strong> 的主动加表锁</h3><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> AUTOCOMMIT=<span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"keyword\">LOCK</span> <span class=\"keyword\">TABLES</span> 表<span class=\"number\">1</span> WRITE, 表<span class=\"number\">2</span> <span class=\"keyword\">READ</span>, ...; </span><br><span class=\"line\">[<span class=\"keyword\">do</span> something <span class=\"keyword\">with</span> <span class=\"keyword\">tables</span> t1 <span class=\"keyword\">and</span> t2 here]; </span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>; </span><br><span class=\"line\"><span class=\"keyword\">UNLOCK</span> <span class=\"keyword\">TABLES</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>使用 <strong>LOCK TABLES</strong> 和 <strong>UNLOCK TABLES</strong> 语句来主动实现对表加锁和解锁。</p></li><li><p>但这都是在服务器层（<strong>MySQL Server</strong> 层）实现的和存储引擎无关，它们有自己的用途并不能替代事务处理。因此除了禁用了 <strong>AUTOCOMMIT</strong> 后可以使用，其他情况不建议使用。</p></li><li><p><strong>LOCK TABLES</strong> 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。</p></li><li><p><strong>UNLOCK TABLES</strong> 可以释放当前线程获得的任何锁定。当前线程执行另一个 <strong>LOCK TABLES</strong> 或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁。</p></li><li><p>在用 <strong>LOCK TABLES</strong> 对 <strong>InnoDB</strong> 的表加锁时要注意，要先将 <strong>AUTOCOMMIT</strong> 设为 <strong>0</strong>，否则 <strong>MySQL</strong> 不会给表加锁。</p></li><li><p>事务结束前，不要用 <strong>UNLOCK TABLES</strong> 释放表锁，因为 <strong>UNLOCK TABLES</strong> 会隐含地提交事务。</p></li><li><p><strong>COMMIT</strong> 或 <strong>ROLLBACK</strong> 并不能释放用 <strong>LOCK TABLES</strong> 加的表锁，必须用 <strong>UNLOCK TABLES</strong> 来主动释放表锁。</p></li><li><p>给表显示加表级锁（ <strong>InnoDB</strong> 表和 <strong>MyISAM</strong> 都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与 <strong>MyISAM</strong> 默认的表锁行为类似）</p></li><li><p>在用 <strong>LOCK TABLES</strong> 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 <strong>MySQL</strong> 不支持锁升级。也就是说，在执行 <strong>LOCK TABLES</strong> 后，只能访问显式加锁的这些表，不能访问未加锁的表。同时，如果加的是读锁那么只能执行查询操作，而不能执行更新操作。</p></li><li><p>其实，在 <strong>MyISAM</strong> 自动加锁（表锁）的情况下也大致如此，<strong>MyISAM</strong> 总是一次获得 <strong>SQL</strong> 语句所需要的全部锁，这也正是 <strong>MyISAM</strong> 表不会出现死锁（<strong>Deadlock Free</strong>）的原因。</p></li><li><p>举例：</p></li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 有一个订单表 **orders**，其中记录有各订单的总金额 **total**，同时还有一个 订单明细表 **order_detail**，其中记录有各订单每一产品的金额小计 **subtotal**，假设我们需要检 查这两个表的金额合计是否相符</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(total) <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(subtotal) <span class=\"keyword\">FROM</span> order_detail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail 表可能已经发生了改变。因此，正确的方法应该是：</span></span><br><span class=\"line\"><span class=\"keyword\">LOCK</span> <span class=\"keyword\">TABLES</span> orders <span class=\"keyword\">READ</span> <span class=\"keyword\">LOCAL</span>, order_detail <span class=\"keyword\">READ</span> <span class=\"keyword\">LOCAL</span>; </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(total) <span class=\"keyword\">FROM</span> orders; </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(subtotal) <span class=\"keyword\">FROM</span> order_detail; </span><br><span class=\"line\"><span class=\"keyword\">UNLOCK</span> <span class=\"keyword\">TABLES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在 LOCK TABLES 时加了 LOCAL 选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持并发插入）</span></span><br></pre></td></tr></tbody></table></figure><h2 id=\"死锁（Deadlock-Free）\"><a href=\"#死锁（Deadlock-Free）\" class=\"headerlink\" title=\"死锁（Deadlock Free）\"></a>死锁（<strong>Deadlock Free</strong>）</h2><ul><li><p>这里的死锁只针对 <strong>InnoDB</strong>，因为 <strong>MyISAM</strong> 是一次性获取所有的锁，所以不会产生死锁。</p></li><li><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p></li><li><p>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</p></li><li><p>锁的行为顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会。</p></li><li><p>死锁的产生主要是原因：真正的数据冲突和存储引擎的实现方式。</p></li><li><p>数据库系统实现了各种死锁检测和死锁超时的机制。<strong>InnoDB</strong> 存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p></li><li><p>死锁发生以后，只有部分或完全回滚其中一个事务才能打破死锁，<strong>InnoDB</strong> 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p></li><li><p>发生死锁后，<strong>InnoDB</strong> 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，<strong>InnoDB</strong> 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 <strong>innodb_lock_wait_timeout</strong> 来解决。</p></li><li><p>死锁会影响性能而不是会产生严重错误，因为 <strong>InnoDB</strong> 会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用 <strong>innodb_deadlock_detect</strong> 配置选项）可能会更有效，这时可以依赖等待超时参数 <strong>innodb_lock_wait_timeout</strong> 设置来进行事务回滚。</p></li><li><p>为了在单个 <strong>InnoDB</strong> 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个行使用 <strong>SELECT … FOR UPDATE</strong> 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p></li><li><p>在事务中如果要更新记录，应该直接申请足够级别的锁，即排他写锁，而不应先申请共享读锁，然后更新时再申请排他写锁，因为这时候当用户再申请排他写锁时，其他事务可能又已经获得了相同记录的共享读锁，从而造成锁冲突，甚至死锁。</p></li><li><p>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会<br>通过 <strong>SELECT … LOCK IN SHARE MODE</strong> 获取行的共享读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</p></li><li><p>根据具体情况适当的调整事务隔离级别。</p></li><li><p>如果出现死锁，可以用 <strong>SHOW INNODB STATUS</strong> 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 <strong>SQL</strong> 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p></li><li><p>尽量使用较低的隔离级别。</p></li><li><p>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</p></li><li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小。</p></li><li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</p></li><li><p>不要申请超过实际需要的锁级别。</p></li><li><p>除非必须，查询时不要显示加锁。<strong>MySQL</strong> 可以实现事务中的查询不用加锁优化事务性能。但只在 <strong>COMMITTED READ（读提交）</strong>和 <strong>REPEATABLE READ（可重复读）</strong>两种隔离级别下工作。</p></li><li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p></li></ul><h2 id=\"乐观锁（Optimistic-Lock）和悲观锁（Pessimistic-Lock）\"><a href=\"#乐观锁（Optimistic-Lock）和悲观锁（Pessimistic-Lock）\" class=\"headerlink\" title=\"乐观锁（Optimistic Lock）和悲观锁（Pessimistic Lock）\"></a>乐观锁（Optimistic Lock）和悲观锁（Pessimistic Lock）</h2><ul><li><p><strong>乐观锁(Optimistic Lock)：</strong></p><ul><li><p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p></li><li><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 <strong>write_condition</strong> 机制的其实都是提供的乐观锁。</p></li></ul></li><li><p><strong>悲观锁（Pessimistic Lock）：</strong></p><ul><li><p>假设一定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p></li><li><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会等待，直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></li></ul></li><li><p>一言蔽之：乐观锁先执行后上锁，悲观锁先上锁后执行。</p></li></ul></body></html>","prev":{"title":"markdown查漏补缺","slug":"markdown查漏补缺"},"next":{"title":"mysql事务","slug":"mysql事务"},"link":"/post/mysql的锁/","toc":[{"title":"","id":"乐观锁（Optimistic-Lock）和悲观锁（Pessimistic-Lock）","index":"1"}],"reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/mysql的锁/\" title=\"mysql的锁\">/post/mysql的锁/</a>"}}
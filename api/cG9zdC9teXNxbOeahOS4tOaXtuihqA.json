{"title":"mysql的临时表","date":"2017-05-13T12:23:38.000Z","slug":"mysql的临时表","comments":true,"tags":["mysql","临时表"],"categories":["mysql"],"updated":"2019-03-29T03:22:48.000Z","content":"<html><head></head><body><h2 id=\"MySQL-默认外部临时表\"><a href=\"#MySQL-默认外部临时表\" class=\"headerlink\" title=\"MySQL 默认外部临时表\"></a><strong>MySQL</strong> 默认外部临时表</h2><ul><li><p><strong>MySQL</strong> 临时表在我们需要保存一些临时数据时是非常有用的，主要用于对大数据量的表上作一个子集，提高查询效率。临时表只在当前连接可见，当关闭连接时，<strong>Mysql</strong> 会自动删除表并释放所有空间。 <strong>PHP</strong> 方式调用 <strong>MySQL</strong> 时，脚本结束之后临时表就被销毁了，其他情况都是在客户端链接关闭之后才会销毁，当然也可以手动销毁。</p></li><li><p>使用方式和普通表类似，不过还是有一些区别的：</p><ul><li><p>创建临时表的时候加上 <strong>TEMPORARY</strong>。</p><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TEMPORARY</span> <span class=\"keyword\">TABLE</span> 表名()</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 <strong>SHOW TABLES</strong> 命令是看不到创建的临时表的。</p></li><li><p>使用 <strong>SHOW CREATE TABLE</strong> 可以查看临时表。</p></li><li><p>在 <strong>information_schema</strong> 中也不存在临时表的信息。</p></li><li><p>退出 <strong>mysql</strong> 连接之后再登陆进去时，临时表已经被销毁了。</p><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql>  SELECT * FROM 表名; # ERROR 1146: Table '表名' doesn't exist</span><br></pre></td></tr></tbody></table></figure></li><li><p>或者使用 <strong>DROP 表名</strong> 来手动销毁临时表也一样。</p><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql>  DROP TABLE 表名;</span><br><span class=\"line\">mysql>  SELECT * FROM 表名; # ERROR 1146: Table '表名' doesn't exist</span><br></pre></td></tr></tbody></table></figure></li><li><p>不同连接的临时表所属各自的作用域，所以不用担心表名重复，如果同一个连接中的临时表和正常表名称相同，则正常表隐藏，临时表将会覆盖掉它。</p></li><li><p>创建临时表不会引发通常的 <strong>COMMIT</strong> 事务提交。</p></li><li><p>临时表不支持 <strong>MySQL</strong> 的集群。</p></li><li><p>临时表不能使用 <strong>RENAME</strong> 来重命名，只能用 <strong>ALTER TABLE 表名1 表名2</strong> 这种形式。</p></li><li><p>同一个查询语句中同一个临时表只能引用一次，但是可以有多个不同的临时表。</p></li><li><p>同一个用户存储函数中同一个临时表也只能引用一次。</p></li><li><p>会对 <strong>MySQL</strong> 的主从复制有一定的影响。</p></li><li><p>临时表的引擎类型只能是：<strong>MEMORY（HEAP）</strong>，<strong>MYISAM</strong>，<strong>MERGE</strong>，<strong>INNODB</strong></p></li></ul></li></ul><h2 id=\"外部内存表\"><a href=\"#外部内存表\" class=\"headerlink\" title=\"外部内存表\"></a>外部内存表</h2><ul><li>在创建临时表时声明引擎类型为 <strong>MEMORY（HEAP）</strong> ，则 <strong>MySQL</strong> 会在内存中创建该临时表，即内存表。</li></ul><figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TEMPORARY</span> <span class=\"keyword\">TABLE</span> 表名 (...) <span class=\"keyword\">TYPE</span> = <span class=\"keyword\">HEAP</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>内存表的 <strong>MEMORY（HEAP）</strong> 引擎不支持 <strong>BLOB/TEXT</strong> 数据类型的字段。</p></li><li><p>临时表的表和数据都存储在内存中，而内存表的表建在磁盘中而数据存储在内存中。</p></li><li><p>内存表和临时表的容量大小都可以在 <strong>MySQL</strong> 的配置中设置，当内存表的数据使用超出容量时会报错，临时表则会把数据写入到磁盘中，此时需要大量的 <strong>I/O</strong> 操作，引起性能的下降。</p></li><li><p>临时表一般比较少用，一般只在确定不能用索引的时候或者在存储过程中某些固定数据使用次数非常多的时候使用临时表。通常是在应用程序中动态创建或者由 <strong>MySQL</strong> 内部根据执行计划需要自己创建。内存表则大多作为 <strong>Cache</strong> 来使用。如今随着 <strong>memcache</strong> ，<strong>redis</strong> 等第三方 <strong>Cache</strong> 的流行，越来越少选择使用内存表。</p></li></ul><h2 id=\"内部临时表\"><a href=\"#内部临时表\" class=\"headerlink\" title=\"内部临时表\"></a>内部临时表</h2><ul><li><p>在某些情况下，<strong>MySQL</strong> 服务器会自动创建内部临时表。使用 <strong>EXPLAIN</strong> 查看查询语句的执行计划，如果 <strong>extra</strong> 列显示 <strong>“using temporary”</strong> 即使用了内部临时表。</p></li><li><p>内部临时表的创建条件：</p><ul><li><p><strong>UNION</strong> 查询。</p></li><li><p>用到 <strong>TEMPTABLE</strong> 算法或者是 <strong>UNION</strong> 查询中的视图。</p></li><li><p><strong>ORDER BY</strong> 和 <strong>GROUP BY</strong> 的子句不一样时。</p></li><li><p>表连接中 <strong>ORDER BY</strong> 的列不是驱动表中的时候。</p></li><li><p><strong>DISTINCT</strong> 查询并且加上 <strong>ORDER BY</strong> 时。</p></li><li><p><strong>SQL</strong> 中用到 <strong>SQL_SMALL_RESULT</strong> 选项时。</p></li><li><p><strong>FROM</strong> 中的子查询。</p></li></ul></li></ul></body></html>","prev":{"title":"mysql的存储引擎innodb和myisam之间的比较","slug":"mysql的存储引擎innodb和myisam之间的比较"},"next":{"title":"mysql高可用架构设计","slug":"mysql高可用架构设计"},"link":"/post/mysql的临时表/","toc":[{"title":"","id":"内部临时表","index":"1"}],"reward":true,"copyright":{"license":"原创版权，转载请注明来源 (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","author":"沈捷译","link":"<a href=\"/post/mysql的临时表/\" title=\"mysql的临时表\">/post/mysql的临时表/</a>"}}